/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PixelPerfectImage
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // Menu options
  showFileInfo: true,
  showShowInFileExplorer: true,
  showRenameOption: true,
  showOpenInNewTab: true,
  showOpenInDefaultApp: true,
  showPercentageResize: true,
  customResizeWidths: [],
  // disabled by default
  // Mousewheel zoom defaults
  enableWheelZoom: true,
  wheelModifierKey: "Alt",
  wheelZoomPercentage: 20,
  invertScrollDirection: false,
  // External editor defaults
  externalEditorName: "",
  externalEditorPathMac: "",
  externalEditorPathWin: "",
  // Debug defaults
  debugMode: false
};
function getExternalEditorPath(settings) {
  return import_obsidian.Platform.isMacOS ? settings.externalEditorPathMac : settings.externalEditorPathWin;
}
var PixelPerfectImageSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Menu options").setHeading();
    new import_obsidian.Setting(containerEl).setName("Show file information").setDesc("Show file information in the context menu").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showFileInfo).onChange(async (value) => {
        this.plugin.settings.showFileInfo = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show in file explorer").setDesc("Show option to reveal image in system file explorer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showShowInFileExplorer).onChange(async (value) => {
      this.plugin.settings.showShowInFileExplorer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show rename option").setDesc("Show option to rename image file").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRenameOption).onChange(async (value) => {
      this.plugin.settings.showRenameOption = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show open in new tab").setDesc("Show option to open image in new tab").addToggle((toggle) => toggle.setValue(this.plugin.settings.showOpenInNewTab).onChange(async (value) => {
      this.plugin.settings.showOpenInNewTab = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show open in default app").setDesc("Show option to open image in default app").addToggle((toggle) => toggle.setValue(this.plugin.settings.showOpenInDefaultApp).onChange(async (value) => {
      this.plugin.settings.showOpenInDefaultApp = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show percentage resize").setDesc("Show percentage resize options (100%, 50%, 25%) in the context menu. Custom sizes will always be shown if defined.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPercentageResize).onChange(async (value) => {
      this.plugin.settings.showPercentageResize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom resize width").setDesc("Set custom resize widths in pixels (comma-separated, e.g. 600,800,1200)").addText((text) => {
      text.setPlaceholder("e.g., 600,800,1200").setValue(this.plugin.settings.customResizeWidths.length > 0 ? this.plugin.settings.customResizeWidths.join(",") : "").onChange(async (value) => {
        const widths = value.split(",").map((part) => parseInt(part.trim())).filter((width) => !isNaN(width) && width > 0);
        this.plugin.settings.customResizeWidths = widths;
        await this.plugin.saveSettings();
      });
    }).addText((text) => {
      text.inputEl.style.width = "30px";
      text.inputEl.style.textAlign = "left";
      text.inputEl.style.border = "none";
      text.inputEl.style.backgroundColor = "transparent";
      text.setValue("px");
      text.setDisabled(true);
    });
    new import_obsidian.Setting(containerEl).setName("Mousewheel zoom").setHeading();
    new import_obsidian.Setting(containerEl).setName("Enable mousewheel zoom").setDesc("Hold modifier key and scroll to resize images").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableWheelZoom).onChange(async (value) => {
        this.plugin.settings.enableWheelZoom = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Modifier key").setDesc("Key to hold while scrolling to zoom images").addDropdown((dropdown) => {
      const isMac = import_obsidian.Platform.isMacOS;
      dropdown.addOption("Alt", isMac ? "Option" : "Alt").addOption("Ctrl", "Ctrl").addOption("Shift", "Shift").setValue(this.plugin.settings.wheelModifierKey).onChange(async (value) => {
        this.plugin.settings.wheelModifierKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Zoom step size").setDesc("Percentage to zoom per scroll step").addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.wheelZoomPercentage = DEFAULT_SETTINGS.wheelZoomPercentage;
        await this.plugin.saveSettings();
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const valueDisplay = createSpan();
      valueDisplay.style.minWidth = "2.5em";
      valueDisplay.style.textAlign = "right";
      valueDisplay.style.marginRight = "1em";
      const updateDisplay = (value) => {
        valueDisplay.setText(`${value}%`);
      };
      slider.setDynamicTooltip().setLimits(1, 100, 1).setValue(this.plugin.settings.wheelZoomPercentage).onChange(async (value) => {
        updateDisplay(value);
        this.plugin.settings.wheelZoomPercentage = value;
        await this.plugin.saveSettings();
      });
      updateDisplay(this.plugin.settings.wheelZoomPercentage);
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(valueDisplay);
    });
    new import_obsidian.Setting(containerEl).setName("Invert scroll direction").setDesc("Invert the zoom direction when scrolling").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.invertScrollDirection).onChange(async (value) => {
        this.plugin.settings.invertScrollDirection = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("External editor").setHeading();
    new import_obsidian.Setting(containerEl).setName("External editor name").setDesc("Name of your external editor (e.g., Photoshop)").addText((text) => {
      text.setPlaceholder("Photoshop").setValue(this.plugin.settings.externalEditorName).onChange(async (value) => {
        this.plugin.settings.externalEditorName = value;
        await this.plugin.saveSettings();
      });
    });
    if (import_obsidian.Platform.isMacOS) {
      new import_obsidian.Setting(containerEl).setName("External editor path (MacOS)").setDesc("Full path to your external editor application on MacOS").addText((text) => {
        text.setPlaceholder("/Applications/Adobe Photoshop 2025/Adobe Photoshop 2025.app").setValue(this.plugin.settings.externalEditorPathMac).onChange(async (value) => {
          const cleanedPath = value.replace(/\\ /g, " ");
          this.plugin.settings.externalEditorPathMac = cleanedPath;
          await this.plugin.saveSettings();
        });
      });
    }
    if (import_obsidian.Platform.isWin) {
      new import_obsidian.Setting(containerEl).setName("External editor path (Windows)").setDesc("Full path to your external editor application on Windows").addText((text) => {
        text.setPlaceholder("C:\\Program Files\\Adobe\\Adobe Photoshop 2025\\Photoshop.exe").setValue(this.plugin.settings.externalEditorPathWin).onChange(async (value) => {
          const cleanedPath = value.replace(/\\ /g, " ");
          this.plugin.settings.externalEditorPathWin = cleanedPath;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("Developer").setHeading();
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging to console").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/main.ts
var import_path = require("path");
var import_child_process = require("child_process");
var RESIZE_PERCENTAGES = [100, 50, 25];
var WIKILINK_IMAGE_REGEX = /(!\[\[)([^\]]+)(\]\])/g;
var MARKDOWN_IMAGE_REGEX = /!\[([^\]]*)\]\(([^)]+)\)/g;
var PixelPerfectImage = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    /** Cache to store image dimensions to avoid repeated file reads */
    this.dimensionCache = /* @__PURE__ */ new Map();
    this.isModifierKeyHeld = false;
    this.wheelEventCleanup = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PixelPerfectImageSettingTab(this.app, this));
    this.registerImageContextMenu();
    this.registerDomEvent(document, "click", this.handleImageClick.bind(this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => this.registerWheelEvents(window))
    );
    this.registerWheelEvents(window);
    this.debugLog("Plugin loaded");
  }
  onunload() {
    this.isModifierKeyHeld = false;
    this.dimensionCache.clear();
  }
  setModifierKeyState(isHeld) {
    this.isModifierKeyHeld = isHeld;
    this.debugLog(`Modifier key ${isHeld ? "pressed" : "released"}`);
  }
  registerWheelEvents(currentWindow) {
    if (this.wheelEventCleanup) {
      this.wheelEventCleanup();
      this.wheelEventCleanup = null;
    }
    const doc = currentWindow.document;
    const keydownHandler = (evt) => {
      if (this.isModifierKeyMatch(evt)) {
        this.setModifierKeyState(true);
      }
    };
    const keyupHandler = (evt) => {
      if (this.isModifierKeyMatch(evt)) {
        this.setModifierKeyState(false);
      }
    };
    const blurHandler = () => {
      if (this.isModifierKeyHeld) {
        this.setModifierKeyState(false);
      }
    };
    const wheelHandler = async (ev) => {
      if (!this.settings.enableWheelZoom || !this.isModifierKeyHeld) return;
      if (!this.isModifierKeyStillHeld(ev)) {
        this.setModifierKeyState(false);
        return;
      }
      const img = this.findImageElement(ev.target);
      if (!img) return;
      ev.preventDefault();
      try {
        await this.handleImageWheel(ev, img);
      } catch (error) {
        this.errorLog("Error handling wheel event:", error);
        new import_obsidian2.Notice("Failed to resize image");
      }
    };
    this.registerDomEvent(doc, "keydown", keydownHandler);
    this.registerDomEvent(doc, "keyup", keyupHandler);
    this.registerDomEvent(window, "blur", blurHandler);
    doc.addEventListener("wheel", wheelHandler, { passive: false });
    this.wheelEventCleanup = () => {
      doc.removeEventListener("wheel", wheelHandler);
      this.debugLog("Wheel events cleaned up");
    };
  }
  isModifierKeyMatch(evt) {
    const key = this.settings.wheelModifierKey.toLowerCase();
    const eventKey = evt.key.toLowerCase();
    switch (key) {
      case "alt":
        return eventKey === "alt" || eventKey === "option";
      case "ctrl":
        return eventKey === "ctrl" || eventKey === "control";
      case "shift":
        return eventKey === "shift";
      default:
        return false;
    }
  }
  isModifierKeyStillHeld(evt) {
    switch (this.settings.wheelModifierKey.toLowerCase()) {
      case "alt":
        return evt.altKey;
      case "ctrl":
        return evt.ctrlKey;
      case "shift":
        return evt.shiftKey;
      default:
        return false;
    }
  }
  async handleImageWheel(evt, target) {
    if (!this.settings.enableWheelZoom) return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!(markdownView == null ? void 0 : markdownView.file)) return;
    const result = await this.getImageFileWithErrorHandling(target);
    if (!result) return;
    const { width } = await this.readImageDimensions(result.imgFile);
    const customWidth = this.getCurrentImageWidth(target, result.activeFile, result.imgFile);
    const currentWidth = customWidth != null ? customWidth : width;
    const deltaScale = Math.min(1, Math.abs(evt.deltaY) / 10);
    const stepSize = Math.max(1, Math.round(currentWidth * (this.settings.wheelZoomPercentage / 100) * deltaScale));
    const scrollingUp = evt.deltaY < 0;
    const shouldIncrease = this.settings.invertScrollDirection ? !scrollingUp : scrollingUp;
    const newWidth = shouldIncrease ? currentWidth + stepSize : Math.max(1, currentWidth - stepSize);
    if (newWidth !== currentWidth) {
      await this.updateImageLinkWidth(result.imgFile, newWidth);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Context Menu Handlers
  // ----------------------
  /**
   * Registers a context menu handler for images in the editor.
   * The menu provides options to view image dimensions and resize the image.
   */
  registerImageContextMenu() {
    this.registerDomEvent(document, "contextmenu", this.handleContextMenu.bind(this));
    let longPressTimer;
    let isLongPress = false;
    this.registerDomEvent(document, "touchstart", (ev) => {
      if (ev.touches.length > 1) return;
      const img = this.findImageElement(ev.target);
      if (!img) return;
      isLongPress = false;
      longPressTimer = setTimeout(() => {
        isLongPress = true;
        this.handleContextMenu(ev);
      }, 500);
    });
    this.registerDomEvent(document, "touchend", () => {
      clearTimeout(longPressTimer);
    });
    this.registerDomEvent(document, "touchmove", () => {
      clearTimeout(longPressTimer);
    });
  }
  async handleContextMenu(ev) {
    if ("touches" in ev && ev.touches.length > 1) return;
    const img = this.findImageElement(ev.target);
    if (!img) return;
    ev.preventDefault();
    const menu = new import_obsidian2.Menu();
    await this.addDimensionsMenuItem(menu, img);
    await this.addResizeMenuItems(menu, ev);
    if (!import_obsidian2.Platform.isMobile) {
      menu.addSeparator();
      this.addFileOperationMenuItems(menu, img);
    }
    const position = {
      x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,
      y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY
    };
    menu.showAtPosition(position);
  }
  /**
   * Helper to find an image element from an event target
   * @param target - The event target or HTML element
   * @returns The found image element or null
   */
  findImageElement(target) {
    if (!target || !(target instanceof HTMLElement)) return null;
    if (target instanceof HTMLImageElement) return target;
    const isImageContext = target.matches('.image-container, .image-embed, img, a.internal-embed[src*=".png"], a.internal-embed[src*=".jpg"], a.internal-embed[src*=".jpeg"], a.internal-embed[src*=".gif"], a.internal-embed[src*=".webp"], a.internal-embed[src*=".svg"]');
    if (isImageContext) {
      return target.querySelector("img");
    }
    return null;
  }
  /**
   * Helper to create a disabled menu item for displaying information
   * @param menu - The menu to add the item to
   * @param title - The title of the menu item
   * @param icon - The icon to use
   */
  addInfoMenuItem(menu, title, icon) {
    menu.addItem((item) => {
      item.setTitle(title).setIcon(icon).setDisabled(true);
    });
  }
  /**
   * Adds an informational menu item showing the actual dimensions of the image.
   * Reads dimensions from the image file in the vault.
   * @param menu - The context menu to add the item to
   * @param img - The HTML image element that was right-clicked
   */
  async addDimensionsMenuItem(menu, img) {
    if (!this.settings.showFileInfo) return;
    try {
      const result = await this.getImageFileWithErrorHandling(img);
      if (!result) return;
      const { width, height } = await this.readImageDimensions(result.imgFile);
      const currentScale = this.calculateImageScale(img, result.activeFile, result.imgFile, width);
      const scaleText = currentScale !== null ? ` @ ${currentScale}%` : "";
      this.addInfoMenuItem(menu, `${result.imgFile.name}${scaleText}`, "image-file");
      this.addInfoMenuItem(menu, `${width} \xD7 ${height} px`, "info");
    } catch (error) {
      this.errorLog("Could not read dimensions:", error);
      new import_obsidian2.Notice("Could not read image dimensions");
    }
  }
  /**
   * Calculates the current scale of an image as a percentage
   * @param img - The HTML image element
   * @param activeFile - The active file
   * @param imageFile - The image file
   * @param actualWidth - The actual width of the image in pixels
   * @returns The current scale as a percentage, or null if no custom width is set
   */
  calculateImageScale(img, activeFile, imageFile, actualWidth) {
    const customWidth = this.getCurrentImageWidth(img, activeFile, imageFile);
    if (customWidth === null) return null;
    return Math.round(customWidth / actualWidth * 100);
  }
  /**
   * Gets the current custom width of an image if set in the link
   * @param img - The HTML image element
   * @param activeFile - The currently active file
   * @param imageFile - The image file
   * @returns The custom width if set, otherwise null
   */
  getCurrentImageWidth(img, activeFile, imageFile) {
    var _a;
    const editor = (_a = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView)) == null ? void 0 : _a.editor;
    if (!editor) return null;
    const docText = editor.getValue();
    let customWidth = null;
    const parseWidth = (pipeParams) => {
      if (pipeParams.length === 0) return null;
      const lastParam = pipeParams[pipeParams.length - 1];
      const width = parseInt(lastParam);
      return isNaN(width) ? null : width;
    };
    for (const match of docText.matchAll(WIKILINK_IMAGE_REGEX)) {
      const [_, _opening, linkInner] = match;
      let [linkWithoutHash] = linkInner.split("#", 1);
      let [linkPath, ...pipeParams] = linkWithoutHash.split("|");
      const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkPath, activeFile.path);
      if ((resolvedFile == null ? void 0 : resolvedFile.path) === imageFile.path) {
        const width = parseWidth(pipeParams);
        if (width !== null) {
          customWidth = width;
          break;
        }
      }
    }
    if (customWidth === null) {
      for (const match of docText.matchAll(MARKDOWN_IMAGE_REGEX)) {
        const [_, description, linkPath] = match;
        let [desc, ...pipeParams] = description.split("|");
        const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkPath, activeFile.path);
        if ((resolvedFile == null ? void 0 : resolvedFile.path) === imageFile.path) {
          const width = parseWidth(pipeParams);
          if (width !== null) {
            customWidth = width;
            break;
          }
        }
      }
    }
    return customWidth;
  }
  /**
   * Helper to safely get the image file with common error handling
   * @param img - The HTML image element
   * @returns Object containing the active file and image file, or null if either cannot be found
   */
  async getImageFileWithErrorHandling(img) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return null;
    }
    const imgFile = this.getFileForImage(img, activeFile);
    if (!imgFile) {
      if (img.naturalWidth > 0 || img.src) {
        new import_obsidian2.Notice("Could not locate image file");
      }
      return null;
    }
    return { activeFile, imgFile };
  }
  /**
   * Helper to wrap menu item click handlers with common error handling
   * @param action - The action to perform
   * @param errorMessage - The message to show on error
   * @returns An async function that can be used as a click handler
   */
  createMenuClickHandler(action, errorMessage) {
    return async () => {
      try {
        await action();
      } catch (error) {
        this.errorLog(errorMessage, error);
        new import_obsidian2.Notice(errorMessage);
      }
    };
  }
  /**
   * Helper to create a menu item with consistent patterns
   * @param menu - The menu to add the item to
   * @param title - The title of the menu item
   * @param icon - The icon to use
   * @param action - The action to perform when clicked
   * @param errorMessage - The error message to show if the action fails
   * @param disabled - Whether the item should be disabled
   */
  addMenuItem(menu, title, icon, action, errorMessage, disabled = false) {
    menu.addItem((item) => {
      item.setTitle(title).setIcon(icon).setDisabled(disabled).onClick(this.createMenuClickHandler(action, errorMessage));
    });
  }
  /**
   * Adds resize percentage options to the context menu.
   * Each option will resize the image to the specified percentage of its original size.
   * @param menu - The context menu to add items to
   * @param ev - The original mouse event
   */
  async addResizeMenuItems(menu, ev) {
    const img = this.findImageElement(ev.target);
    if (!img) return;
    this.addMenuItem(
      menu,
      "Copy Image",
      "copy",
      async () => {
        await this.copyImageToClipboard(img);
        new import_obsidian2.Notice("Image copied to clipboard");
      },
      "Failed to copy image to clipboard"
    );
    this.addMenuItem(
      menu,
      "Copy Local Path",
      "link",
      async () => {
        const result2 = await this.getImageFileWithErrorHandling(img);
        if (!result2) return;
        const vaultPath = this.app.vault.adapter.basePath;
        const fullPath = (0, import_path.join)(vaultPath, (0, import_obsidian2.normalizePath)(result2.imgFile.path));
        await navigator.clipboard.writeText(fullPath);
        new import_obsidian2.Notice("File path copied to clipboard");
      },
      "Failed to copy file path"
    );
    menu.addSeparator();
    const result = await this.getImageFileWithErrorHandling(img);
    let currentScale = null;
    let currentWidth = null;
    if (result) {
      const { width } = await this.readImageDimensions(result.imgFile);
      currentWidth = this.getCurrentImageWidth(img, result.activeFile, result.imgFile);
      currentScale = currentWidth !== null ? Math.round(currentWidth / width * 100) : null;
      this.debugLog("Current image scale:", currentScale, "width:", currentWidth);
    }
    if (this.settings.showPercentageResize) {
      RESIZE_PERCENTAGES.forEach((percentage) => {
        this.addMenuItem(
          menu,
          `Resize to ${percentage}%`,
          "image",
          async () => await this.resizeImage(img, percentage),
          `Failed to resize image to ${percentage}%`,
          currentScale === percentage
        );
      });
    }
    if (this.settings.customResizeWidths.length > 0) {
      this.settings.customResizeWidths.forEach((width) => {
        this.addMenuItem(
          menu,
          `Resize to ${width}px`,
          "image",
          async () => await this.resizeImage(img, width, true),
          `Failed to resize image to ${width}px`,
          currentWidth === width
        );
      });
    }
    if (result && currentScale !== null) {
      this.addMenuItem(
        menu,
        "Remove Custom Size",
        "reset",
        async () => {
          await this.removeImageWidth(result.imgFile);
          new import_obsidian2.Notice("Removed custom size from image");
        },
        "Failed to remove custom size from image"
      );
    }
  }
  /**
   * Adds file operation menu items like Show in Finder/Explorer and Open in Default App
   */
  addFileOperationMenuItems(menu, target) {
    if (import_obsidian2.Platform.isMobile) return;
    const isMac = import_obsidian2.Platform.isMacOS;
    if (this.settings.showShowInFileExplorer) {
      this.addMenuItem(
        menu,
        isMac ? "Show in Finder" : "Show in Explorer",
        "folder-open",
        async () => {
          const result = await this.getImageFileWithErrorHandling(target);
          if (!result) return;
          await this.showInSystemExplorer(result.imgFile);
        },
        "Failed to open system explorer"
      );
    }
    if (this.settings.showRenameOption) {
      this.addMenuItem(
        menu,
        "Rename Image",
        "pencil",
        async () => {
          const result = await this.getImageFileWithErrorHandling(target);
          if (!result) return;
          await this.renameImage(result.imgFile);
        },
        "Failed to rename image"
      );
    }
    if (this.settings.showRenameOption || this.settings.showShowInFileExplorer) {
      menu.addSeparator();
    }
    if (this.settings.showOpenInNewTab) {
      this.addMenuItem(
        menu,
        "Open in New Tab",
        "link-2",
        async () => {
          const result = await this.getImageFileWithErrorHandling(target);
          if (!result) return;
          await this.app.workspace.openLinkText(result.imgFile.path, "", true);
        },
        "Failed to open image in new tab"
      );
    }
    if (this.settings.showOpenInDefaultApp) {
      this.addMenuItem(
        menu,
        "Open in Default app",
        "image",
        async () => {
          const result = await this.getImageFileWithErrorHandling(target);
          if (!result) return;
          await this.openInDefaultApp(result.imgFile);
        },
        "Failed to open in default app"
      );
    }
    const editorPath = getExternalEditorPath(this.settings);
    if (editorPath == null ? void 0 : editorPath.trim()) {
      const editorName = this.settings.externalEditorName.trim() || "External Editor";
      this.addMenuItem(
        menu,
        `Open in ${editorName}`,
        "edit",
        async () => {
          const result = await this.getImageFileWithErrorHandling(target);
          if (!result) return;
          await this.openInExternalEditor(result.imgFile.path);
        },
        `Failed to open image in ${editorName}`
      );
    }
  }
  // Image Operations
  // ----------------
  /**
   * Resizes an image in the editor by updating its wikilink width parameter.
   * @param img - The HTML image element
   * @param size - Either a percentage (e.g. 50) or absolute width in pixels (e.g. 600)
   * @param isAbsolute - If true, size is treated as pixels, otherwise as percentage
   */
  async resizeImage(img, size, isAbsolute = false) {
    const result = await this.getImageFileWithErrorHandling(img);
    if (!result) {
      throw new Error("Could not find the image file");
    }
    const { width } = await this.readImageDimensions(result.imgFile);
    const newWidth = isAbsolute ? size : Math.round(width * size / 100);
    await this.updateImageLinkWidth(result.imgFile, newWidth);
  }
  /**
   * Helper to load an image and get its dimensions
   * @param src - The image source URL
   * @param crossOrigin - Whether to set crossOrigin attribute
   * @returns Promise resolving to the loaded image
   */
  loadImage(src, crossOrigin) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error("Failed to load image"));
      img.src = src;
    });
  }
  /**
   * Helper to create a blob from binary data
   * @param data - The binary data
   * @param type - The MIME type of the data
   * @returns The created blob
   */
  createBlob(data, type) {
    return new Blob([new Uint8Array(data)], { type });
  }
  /**
   * Copies an image to the system clipboard
   * @param targetImg - The HTML image element to copy
   */
  async copyImageToClipboard(targetImg) {
    try {
      const img = await this.loadImage(targetImg.src, "anonymous");
      const canvas = document.createElement("canvas");
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Failed to get canvas context");
      }
      ctx.drawImage(img, 0, 0);
      const blob = await new Promise((resolveBlob) => {
        canvas.toBlob(resolveBlob);
      });
      if (!blob) {
        throw new Error("Failed to create blob");
      }
      const item = new ClipboardItem({ [blob.type]: blob });
      await navigator.clipboard.write([item]);
    } catch (error) {
      this.errorLog("Copy to clipboard failed:", error);
      throw error;
    }
  }
  /**
   * Updates image links in the text using a common transformation logic.
   * Handles both wiki-style (![[image.png|100]]) and markdown-style (![alt|100](image.png)) links.
   * 
   * Examples of transformations:
   * - Input text: "Here's an image: ![[photo.jpg|50]]"
   *   Transform: (params) => ["100"]
   *   Output: "Here's an image: ![[photo.jpg|100]]"
   * 
   * - Input text: "Another image: ![caption|50](photo.jpg)"
   *   Transform: (params) => ["100"]
   *   Output: "Another image: ![caption|100](photo.jpg)"
   * 
   * @param text - The markdown text to update
   * @param activeFile - The currently active file (for resolving relative paths)
   * @param imageFile - The specific image file to update links for
   * @param transform - Function that takes current parameters and returns new ones
   * @returns The text with updated image links
   */
  updateLinks(text, activeFile, imageFile, transform) {
    text = text.replace(WIKILINK_IMAGE_REGEX, (_, opening, linkInner, closing) => {
      const link = this.parseLinkComponents(linkInner);
      if (!this.resolveLink(link.path, activeFile, imageFile)) {
        return _;
      }
      link.params = transform(link.params);
      const newLink = this.buildLinkPath(link);
      return `${opening}${newLink}${closing}`;
    });
    return text.replace(MARKDOWN_IMAGE_REGEX, (match, description, linkPath) => {
      const link = this.parseLinkComponents(description, linkPath);
      if (!this.resolveLink(link.path, activeFile, imageFile)) {
        return match;
      }
      const desc = description.split("|")[0].trim() || imageFile.basename;
      link.params = transform(link.params);
      const newDescription = link.params.length > 0 ? [desc, ...link.params].join("|") : desc;
      return `![${newDescription}](${this.buildLinkPath({ ...link, params: [] })})`;
    });
  }
  /**
   * Parses an Obsidian image link into its components.
   * Handles both wiki-style (![[image.png|100]]) and markdown-style (![alt|100](image.png)) links.
   * 
   * For wiki-style links (![[image.png|100#heading]]):
   * - mainPart = "image.png|100#heading"
   * - linkPath = undefined
   * 
   * For markdown-style links (![alt|100](image.png#heading)):
   * - mainPart = "alt|100" (the part between [] brackets)
   * - linkPath = "image.png#heading" (the part between () parentheses)
   * 
   * @param mainPart - For wiki links: full link content. For markdown links: the alt/description text
   * @param linkPath - Only used for markdown links: the URL/path part in parentheses
   * @returns Parsed components of the link:
   *   - path: The file path without parameters or hash
   *   - hash: The heading reference (e.g., "#heading") if any
   *   - params: Array of parameters (e.g., ["100"] for width)
   *   - isWikiStyle: Whether this is a wiki-style (![[...]]) or markdown-style link
   */
  parseLinkComponents(mainPart, linkPath) {
    const pathToParse = linkPath != null ? linkPath : mainPart;
    const [pathWithoutHash, hashPart] = pathToParse.split("#", 2);
    const hash = hashPart ? `#${hashPart}` : "";
    const [path, ...params] = (linkPath ? mainPart : pathWithoutHash).split("|");
    return {
      path: linkPath != null ? linkPath : path,
      // For markdown links, use the URL part; for wiki links, use the path part
      hash,
      // Any heading reference (#) found
      params,
      // Array of parameters (e.g., width)
      isWikiStyle: !linkPath
      // If linkPath is undefined, it's a wiki-style link
    };
  }
  /**
   * Builds a link path by combining the components of an ImageLink.
   * Used to reconstruct both wiki-style and markdown-style image links.
   * 
   * Examples:
   * - Input: { path: "image.png", params: ["100"], hash: "#heading" }
   *   Output: "image.png|100#heading"
   * 
   * - Input: { path: "image.png", params: [], hash: "" }
   *   Output: "image.png"
   * 
   * - Input: { path: "subfolder/image.png", params: ["200", "left"], hash: "#section" }
   *   Output: "subfolder/image.png|200|left#section"
   * 
   * @param link - The ImageLink object containing path, parameters, and hash
   * @returns The reconstructed link path with parameters and hash (if any)
   */
  buildLinkPath(link) {
    const paramsStr = link.params.length > 0 ? `|${link.params.join("|")}` : "";
    return `${link.path}${paramsStr}${link.hash}`;
  }
  /**
   * Updates image links in the document using a transformation function.
   * @param imageFile - The image file being referenced
   * @param transform - Function that transforms the parameters of the image link
   * @returns Promise<boolean> - True if any changes were made, false otherwise
   */
  async updateImageLinks(imageFile, transform) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      throw new Error("No active file, cannot update link.");
    }
    if (activeFile.path === imageFile.path) {
      return false;
    }
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!markdownView) {
      throw new Error("No active MarkdownView to update.");
    }
    const docText = await this.app.vault.read(activeFile);
    let contentWithoutFrontmatter = docText;
    let frontmatterEndIndex = -1;
    if (docText.startsWith("---\n")) {
      frontmatterEndIndex = docText.indexOf("\n---\n", 4);
      if (frontmatterEndIndex !== -1) {
        frontmatterEndIndex += 5;
        contentWithoutFrontmatter = docText.substring(frontmatterEndIndex);
      }
    }
    const replacedText = this.updateLinks(contentWithoutFrontmatter, activeFile, imageFile, transform);
    if (replacedText !== contentWithoutFrontmatter) {
      try {
        await this.app.vault.process(activeFile, (data) => {
          return frontmatterEndIndex !== -1 ? data.substring(0, frontmatterEndIndex) + replacedText : replacedText;
        });
        return true;
      } catch (error) {
        this.errorLog("Failed to update file content:", error);
        throw new Error("Failed to update image link");
      }
    }
    return false;
  }
  /**
   * Helper to resolve a file path to a TFile in the vault
   * @param linkPath - The path to resolve
   * @param activeFile - The currently active file for path resolution
   * @param imageFile - Optional file to compare against for matching
   * @returns The resolved TFile, or null if not found or doesn't match imageFile
   */
  resolveLink(linkPath, activeFile, imageFile) {
    const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkPath, activeFile.path);
    if (!resolvedFile) return null;
    if (imageFile && resolvedFile.path !== imageFile.path) return null;
    return resolvedFile;
  }
  /**
   * Updates the width parameter in wikilinks that reference a specific image.
   * @param imageFile - The image file being referenced
   * @param newWidth - The new width to set in pixels
   */
  async updateImageLinkWidth(imageFile, newWidth) {
    const didChange = await this.updateImageLinks(imageFile, (params) => {
      const lastParam = params.length > 0 ? params[params.length - 1] : null;
      const lastParamIsNumber = lastParam !== null && !isNaN(parseInt(lastParam));
      if (lastParamIsNumber) {
        return [...params.slice(0, params.length - 1), String(newWidth)];
      } else {
        return [...params, String(newWidth)];
      }
    });
    if (didChange) {
      this.debugLog(`Updated image size to ${newWidth}px`);
    }
  }
  /**
   * Removes the width parameter from image links.
   * @param imageFile - The image file being referenced
   */
  async removeImageWidth(imageFile) {
    const didChange = await this.updateImageLinks(imageFile, (params) => {
      const lastParam = params.length > 0 ? params[params.length - 1] : null;
      const lastParamIsNumber = lastParam !== null && !isNaN(parseInt(lastParam));
      if (lastParamIsNumber) {
        return params.slice(0, params.length - 1);
      } else {
        return params;
      }
    });
    if (didChange) {
      this.debugLog("Removed custom size from image");
    }
  }
  /**
   * Reads an image file from the vault and determines its dimensions.
   * Uses a cache to avoid repeated file reads.
   * @param file - The image file to read
   * @returns Object containing width and height in pixels
   */
  async readImageDimensions(file) {
    if (this.dimensionCache.has(file.path)) {
      return this.dimensionCache.get(file.path);
    }
    try {
      const data = await this.app.vault.readBinary(file);
      const blob = this.createBlob(data, "image/*");
      const url = URL.createObjectURL(blob);
      try {
        const img = await this.loadImage(url);
        const dimensions = { width: img.width, height: img.height };
        this.dimensionCache.set(file.path, dimensions);
        return dimensions;
      } finally {
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      this.errorLog("Failed to read image file:", error);
      throw error;
    }
  }
  // File & Path Utilities
  // ---------------------
  /**
   * Resolves an HTML image element to its corresponding vault file.
   * @param img - The HTML image element
   * @param activeFile - The currently active file for path resolution
   * @returns The corresponding TFile or null if not found
   */
  getFileForImage(img, activeFile) {
    var _a;
    const src = (_a = img.getAttribute("src")) != null ? _a : "";
    let wikiLink = img.getAttribute("alt");
    const srcFileName = this.parseFileNameFromSrc(src);
    if (srcFileName) {
      const fileFromSrc = this.resolveLink(srcFileName, activeFile);
      if (fileFromSrc) {
        return fileFromSrc;
      }
    }
    if (wikiLink) {
      wikiLink = wikiLink.split("|")[0].trim();
      const fileFromLink = this.resolveLink(wikiLink, activeFile);
      if (fileFromLink) {
        return fileFromLink;
      }
    }
    return null;
  }
  /**
   * Extracts a filename from an image's src attribute.
   * Used as fallback when alt text is not available.
   * @param src - The src attribute value
   * @returns The extracted filename or null if not found
   */
  parseFileNameFromSrc(src) {
    try {
      const decodedSrc = decodeURIComponent(src);
      const [pathWithoutQuery] = decodedSrc.split("?");
      const slashIdx = pathWithoutQuery.lastIndexOf("/");
      if (slashIdx < 0 || slashIdx >= pathWithoutQuery.length - 1) {
        return null;
      }
      return pathWithoutQuery.substring(slashIdx + 1);
    } catch (error) {
      this.debugLog("Error parsing src:", error);
      return null;
    }
  }
  // Platform & Debug Utilities
  // --------------------------
  /**
   * Logs debug messages when debug mode is enabled in settings.
   * @param args - Arguments to log
   */
  debugLog(...args) {
    if (this.settings.debugMode) {
      const timestamp = (/* @__PURE__ */ new Date()).toTimeString().split(" ")[0];
      console.log(`${timestamp}`, ...args);
    }
  }
  /**
   * Logs error messages with timestamp.
   * @param args - Arguments to log
   */
  errorLog(...args) {
    const timestamp = (/* @__PURE__ */ new Date()).toTimeString().split(" ")[0];
    console.error(`${timestamp}`, ...args);
  }
  /**
   * Shows the file in system explorer (Finder on macOS)
   */
  async showInSystemExplorer(file) {
    this.app.showInFolder(file.path);
  }
  /**
   * Opens the file in the default system app
   */
  async openInDefaultApp(file) {
    this.app.openWithDefaultApp(file.path);
  }
  // --- Add a helper function to launch external editor
  openInExternalEditor(filePath) {
    const editorPath = getExternalEditorPath(this.settings);
    const editorName = this.settings.externalEditorName.trim() || "External Editor";
    if (!editorPath) {
      new import_obsidian2.Notice(`Please set your ${editorName} path in Pixel Perfect Image settings.`);
      return;
    }
    const adapter = this.app.vault.adapter;
    if (!(adapter instanceof import_obsidian2.FileSystemAdapter)) {
      new import_obsidian2.Notice("Cannot open file: Vault is not a FileSystemAdapter");
      return;
    }
    const vaultPath = adapter.getBasePath();
    const absoluteFilePath = (0, import_path.join)(vaultPath, (0, import_obsidian2.normalizePath)(filePath));
    let cmd;
    if (import_obsidian2.Platform.isMacOS) {
      cmd = `open -a "${editorPath}" "${absoluteFilePath}"`;
    } else {
      cmd = `"${editorPath}" "${absoluteFilePath}"`;
    }
    (0, import_child_process.exec)(cmd, (error) => {
      if (error) {
        this.errorLog(`Error launching ${editorName}:`, error);
        new import_obsidian2.Notice(`Could not open file in ${editorName}.`);
      } else {
        this.debugLog(`Launched ${editorName}:`, cmd);
      }
    });
  }
  async renameImage(file) {
    var _a;
    const newName = await this.promptForNewName(file);
    if (!newName) return;
    try {
      const dirPath = ((_a = file.parent) == null ? void 0 : _a.path) || "/";
      const newPath = `${dirPath}/${newName}`;
      await this.app.fileManager.renameFile(file, newPath);
      new import_obsidian2.Notice("Image renamed successfully");
    } catch (error) {
      this.errorLog("Failed to rename file:", error);
      new import_obsidian2.Notice("Failed to rename image");
    }
  }
  async promptForNewName(file) {
    return new Promise((resolve) => {
      const modal = new FileNameInputModal(this.app, file.name, (result) => {
        resolve(result);
      });
      modal.open();
    });
  }
  /**
   * Handles click events on images, opening them in a new tab when CMD/CTRL is pressed
   */
  handleImageClick(ev) {
    if (!(ev.metaKey || ev.ctrlKey)) return;
    const img = this.findImageElement(ev.target);
    if (!img) return;
    ev.preventDefault();
    this.getImageFileWithErrorHandling(img).then((result) => {
      if (result) {
        this.app.workspace.openLinkText(result.imgFile.path, "", true);
        this.debugLog("Opening image in new tab:", result.imgFile.path);
      }
    }).catch((error) => {
      this.errorLog("Failed to open image in new tab:", error);
      new import_obsidian2.Notice("Failed to open image in new tab");
    });
  }
};
var FileNameInputModal = class extends import_obsidian2.Modal {
  constructor(app, originalName, onSubmit) {
    super(app);
    this.result = null;
    this.originalName = originalName;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.style.padding = "0.8em 1.2em";
    contentEl.createEl("h2", {
      text: "Rename image",
      cls: "modal-title"
      // Add class for consistency
    }).style.marginTop = "0";
    const form = contentEl.createEl("form");
    form.style.display = "flex";
    form.style.flexDirection = "column";
    form.style.gap = "0.8em";
    const input = form.createEl("input", {
      type: "text",
      value: this.originalName
    });
    input.style.width = "100%";
    const lastDotIndex = this.originalName.lastIndexOf(".");
    if (lastDotIndex > 0) {
      const nameWithoutExt = this.originalName.substring(0, lastDotIndex);
      input.setSelectionRange(0, nameWithoutExt.length);
    }
    const buttonContainer = form.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "0.8em";
    buttonContainer.style.marginTop = "0.4em";
    const submitButton = buttonContainer.createEl("button", {
      text: "Rename",
      type: "submit",
      cls: "mod-cta"
      // Add Obsidian's accent class
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      type: "button"
    });
    cancelButton.addEventListener("click", () => {
      this.onSubmit(null);
      this.close();
    });
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const newName = input.value.trim();
      if (newName && newName !== this.originalName) {
        this.onSubmit(newName);
      } else {
        this.onSubmit(null);
      }
      this.close();
    });
    input.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.result === void 0) {
      this.onSubmit(null);
    }
  }
};


/* nosourcemap */